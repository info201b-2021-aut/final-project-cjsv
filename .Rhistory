# `states` dataframe into the variable `joined_states`.
joined_states <- merge(x = sum_county_to_state, y = states, all = TRUE)
View(joined_states)
# Oh no! An inconsistency -- let's dig further into this. Let's see if we can
# find out *where* this inconsistency lies. Let's take the county level data,
# and add up all of the cases to the state level on each day (e.g.,
# aggregating to the state level). Store this dataframe with three columns
# (state, date, county_totals) in the variable `sum_county_to_state`.
# (To avoid DPLYR automatically grouping your results,
# specify `.groups = "drop"` in your `summarize()` statement. This is a bit of
# an odd behavior....)
sum_county_to_state <- counties %>%
group_by(date, state)%>%
summarize(county_totals = sum(cases), .groups = "drop")
joined_states <- merge(x = sum_county_to_state, y = states, all = TRUE)
View(joined_states)
has_discrepancy <- joined_states%>%
select(filter(county_totals != cases))%>%
has_discrepancy <- joined_states%>%
select(filter(county_totals != cases), )%>%
has_discrepancy <- joined_states%>%
select(filter(county_totals != cases), )
# Then, let's join together the `sum_county_to_state` dataframe with the
# `states` dataframe into the variable `joined_states`.
joined_states <- merge(x = sum_county_to_state, y = states, all = TRUE)
# To find out where (and when) there is a discrepancy in the number of cases,
# create the variable `has_discrepancy`, which has *only* the observations
# where the sum of the county cases in each state and the state values are
# different. This will be a *dataframe*.
has_discrepancy <- joined_states%>%
select(filter(county_totals != cases), )
rlang::last_error()
has_discrepancy <- joined_states%>%
filter(county_totals != cases)
View(has_discrepancy)
state_highest_difference <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals, cases))%>%
filter(abs_diff == max(abs_diff))%>%
pull(state)
state_highest_difference <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
filter(abs_diff == max(abs_diff))%>%
pull(state)
View(has_discrepancy)
View(national)
View(counties)
View(states)
state_highest_ratio <- states %>%
mutate(states, deaths_to_cases = deaths/cases)%>%
state_recent <- filter(date == max(date)) %>%
filter(deaths_to_cases == max(deaths_to_cases))%>%
pull(state)
state_highest_ratio <- states %>%
mutate(states, deaths_to_cases = deaths/cases)%>%
state_recent <- filter(date == max(date)) %>%
filter(deaths_to_cases == max(deaths_to_cases))%>%
select(state)
state_highest_ratio <- states %>%
mutate(states, deaths_to_cases = deaths/cases)%>%
filter(date == max(date)) %>%
filter(deaths_to_cases == max(deaths_to_cases))%>%
select(state)
View(state_highest_ratio)
state_lowest_cases <- states %>%
filter(date == max(date))%>%
filter(cases == min(cases))%>%
select(state)
View(state_lowest_cases)
View(state_lowest_cases)
View(county_highest_cases)
View(lowest_in_each_state)
View(num_highest_cases_county)
state_date_most_cases <- state%>%
mutate(new_cases = cases - lag(cases, default = first(cases)))
filter(new_cases == max(new_cases))
select(date)
state_date_most_cases <- states%>%
mutate(new_cases = cases - lag(cases, default = first(cases)))
filter(new_cases == max(new_cases))
select(date)
states <-  mutate(states, new_cases = cases - lag(cases, default = first(cases)))
state_date_most_cases <- states%>%
filter(new_cases == max(new_cases))
select(date)
states <-  mutate(states, new_cases = cases - lag(cases, default = first(cases)))
state_date_most_cases <- states%>%
filter(new_cases == max(new_cases))
select(date)
states <-  mutate(states, new_cases = cases - lag(cases, default = first(cases)))
state_date_most_cases <- states%>%
filter(new_cases == max(new_cases))
pull(date)
states <-  mutate(states, new_cases = cases - lag(cases, default = first(cases)))
state_date_most_cases <- states%>%
filter(new_cases == max(new_cases))
select(states, date)
states <-  mutate(states, new_cases = cases - lag(cases, default = first(cases)))
state_date_most_cases <- states%>%
filter(new_cases == max(new_cases))
select(date)
date_most_deaths <- select(filter(national, new_deaths == max(new_deaths)), date)
# function).
national <- mutate(national, new_cases = cases - lag(cases, default = first(cases)))
# Similarly, the `deaths` columns *is not* the number of new deaths per day.
# Add (mutate) a new column on your `national` data frame called `new_deaths`
# that has the nubmer of *new* deaths each day
national <- mutate(national, new_deaths = deaths - lag(deaths, default = first(deaths)))
# What was the date when the most new cases occured?
# `date_most_cases`
date_most_cases <- select(filter(national, new_cases == max(new_cases)), date)
# What was the date when the most new deaths occured?
# `date_most_deaths`
date_most_deaths <- select(filter(national, new_deaths == max(new_deaths)), date)
states <-  mutate(states, new_cases = cases - lag(cases, default = first(cases)))
state_date_most_cases <- select(filter(states, new_cases == max(new_cases)), date)
View(state_date_most_cases)
counties <-  mutate(counties, new_cases = cases - lag(cases, default = first(cases)))
county_date_most_cases <- select(filter(counties, new_cases == max(new_cases)), date)
View(county_date_most_cases)
states <-  mutate(states, new_deaths = deaths - lag(deaths, default = first(deaths)))
state_date_most_deaths <- select(filter(states, new_deaths == max(new_deaths)), date)
View(state_date_most_deaths)
View(states)
states <-  mutate(state_by_day, new_deaths = deaths - lag(deaths, default = first(deaths)))
state_date_most_deaths <- select(filter(state_by_day, new_deaths == max(new_deaths)), date)
county_highest_ratio <- counties %>%
mutate(counties, deaths_to_cases = deaths/cases)%>%
filter(date == max(date)) %>%
filter(deaths_to_cases == max(deaths_to_cases))%>%
select(county)
View(county_highest_ratio)
# Which county had the highest ratio of deaths to cases?
county_highest_ratio <- counties %>%
mutate(counties, deaths_to_cases = deaths/cases)%>%
filter(date == max(date)) %>%
filter(deaths_to_cases == max(deaths_to_cases))%>%
select(county)
print(county_highest_ratio)
county_highest_ratio <- counties %>%
mutate(counties, deaths_to_cases = deaths/cases)%>%
filter(date == max(date)) %>%
filter(deaths_to_cases == max(na.omit(deaths_to_cases)))%>%
select(county)
print(county_highest_ratio)
state_highest_diff_amt <- filter(has_discrepancy, abs_diff == max(abs_diff))
state_highest_difference <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
filter(abs_diff == max(abs_diff))%>%
pull(state)
# Independent exploration -------------------------------------------------
# Ask your own 3 questions: in the section below, pose 3 questions,
# then use the appropriate code to answer them.
# What was the highest absolute difference between the sum of the county cases and the reported state cases?
state_highest_diff_amt <- filter(has_discrepancy, abs_diff == max(abs_diff))
state_highest_diff_amt <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
pull(abs_diff == max(abs_diff))
state_highest_diff_amt <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
select(abs_diff == max(abs_diff))
state_highest_diff_amt <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
filter(abs_diff == max(abs_diff))
state_highest_diff_amt <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
filter(abs_diff == max(abs_diff))%>%
select(abs_diff)
View(state_highest_diff_amt)
View(has_discrepancy)
date_highest_diff_amt <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
filter(abs_diff == max(abs_diff))%>%
select(date)
View(date_highest_diff_amt)
state_most_discrepencies <- table(has_discrepancy['state'])
state_most_discrepencies
state_most_discrepencies <- length(has_discrepancy['state'])
state_most_discrepencies <- count(has_discrepancy['state'])
View(state_most_discrepencies)
state_most_discrepencies <- table(has_discrepancy['state'])
state_most_discrepencies <- max(table(has_discrepancy['state']))
state_most_discrepencies <- select(max(table(has_discrepancy['state'])), state)
# Overview ----------------------------------------------------------------
# Assignment 2: U.S. COVID Trends
# For each question/prompt, write the necessary code to calculate the answer.
# For grading, it's important that you store your answers in the variable names
# listed with each question in `backtics`. Please make sure to store the
# appropriate variable type (e.g., a string, a vector, a dataframe, etc.)
# For each prompt marked `Reflection`, please write a response
# in your `README.md` file.
# Loading data ------------------------------------------------------------
# You'll load data at the national, state, and county level. As you move through
# the assignment, you'll need to consider the appropriate data to answer
# each question (though feel free to ask if it's unclear!)
# Load the tidyverse package
install.packages("tidyverse")
library(dplyr)
library(tidyr)
# Load the *national level* data into a variable. `national`
# (hint: you'll need to get the "raw" URL from the NYT GitHub page)
national <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/master/us.csv", stringsAsFactors = FALSE)
# Load the *state level* data into a variable. `states`
states <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-states.csv", stringsAsFactors = FALSE)
# Load the *county level* data into a variable. `counties`
# (this is a large dataset, which may take ~30 seconds to load)
counties <- read.csv("https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv", stringsAsFactors = FALSE)
# How many observations (rows) are in each dataset?
# Create `obs_national`, `obs_states`, `obs_counties`
obs_national <- nrow(national)
obs_states <- nrow(states)
obs_counties <- nrow(counties)
# Reflection: What does each row represent in each dataset?
# How many features (columns) are there in each dataset?
# Create `num_features_national`, `num_features_states`, `num_features_counties`
num_features_national <- ncol(national)
num_features_states <- ncol(states)
num_features_counties <- ncol(counties)
# Exploratory analysis ----------------------------------------------------
# For this section, you should explore the dataset by answering the following
# questions. HINT: Remeber that in class, we talked about how you can answer
# most data analytics questions by selecting specific columns and rows.
# For this assignemnt, you are welcome to use either base R dataframe indexing or
# use functions from the DPLYR package (e.g., using `pull()`). Regardless, you
# must return the specific column being asked about. For example, if you are
# asked the *county* with the highest number of deaths, your answer should
# be a single value (the name of the county: *not* an entire row of data).
# (again, make sure to read the documentation to understand the meaning of
# each row -- it isn't immediately apparent!)
# How many total cases have there been in the U.S. by the most recent date
# in the dataset? `total_us_cases`
total_us_cases <- select(filter(national, date == max(date)), cases)
# How many total deaths have there been in the U.S. by the most recent date
# in the dataset? `total_us_deaths`
total_us_deaths <- select(filter(national, date == max(date)), deaths)
# Which state has had the highest number of cases?
# `state_highest_cases`
state_highest_cases <- select(filter(states, cases == max(cases)), state)
# What is the highest number of cases in a state?
# `num_highest_state`
num_highest_state <- select(filter(states, cases == max(cases)), cases)
# Which state has the highest ratio of deaths to cases (deaths/cases), as of the
# most recent date? `state_highest_ratio`
# (hint: you may need to create a new column in order to do this!)
state_highest_ratio <- states %>%
mutate(states, deaths_to_cases = deaths/cases)%>%
filter(date == max(date)) %>%
filter(deaths_to_cases == max(deaths_to_cases))%>%
select(state)
# Which state has had the lowest number of cases *as of the most recent date*?
# (hint, this is a little trickier to calculate than the maximum because
# of the meaning of the row). `state_lowest_cases`
state_lowest_cases <- states %>%
filter(date == max(date))%>%
filter(cases == min(cases))%>%
select(state)
# Reflection: What did you learn about the dataset when you calculated
# the state with the lowest cases (and what does that tell you about
# testing your assumptions in a dataset)?
# Which county has had the highest number of cases?
# `county_highest_cases`
county_highest_cases <- select(filter(counties, cases == max(cases)), county)
# What is the highest number of cases that have happened in a single county?
# `num_highest_cases_county`
num_highest_cases_county <- select(filter(counties, cases == max(cases)), cases)
# Because there are multiple counties with the same name across states, it
# will be helpful to have a column that stores the county and state together
# (in the form "COUNTY, STATE").
# Add a new column to your `counties` data frame called `location`
# that stores the county and state (separated by a comma and space).
# You can do this by mutating a new column, or using the `unite()` function
# (just make sure to keep the original columns as well)
counties <- counties %>%
unite("location", county:state, sep = ",", remove = FALSE)
# What is the name of the location (county, state) with the highest number
# of deaths? `location_most_deaths`
location_most_deaths <- counties %>%
filter(deaths == max(na.omit(deaths)))%>%
pull(location)
# Reflection: Is the location with the highest number of cases the location with
# the most deaths? If not, why do you believe that may be the case?
# At this point, you (hopefully) have realized that the `cases` column *is not*
# the number of _new_ cases in a day (if not, you may need to revisit your work)
# Add (mutate) a new column on your `national` data frame called `new_cases`
# that has the nubmer of *new* cases each day (hint: look for the `lag`
# function).
national <- mutate(national, new_cases = cases - lag(cases, default = first(cases)))
# Similarly, the `deaths` columns *is not* the number of new deaths per day.
# Add (mutate) a new column on your `national` data frame called `new_deaths`
# that has the nubmer of *new* deaths each day
national <- mutate(national, new_deaths = deaths - lag(deaths, default = first(deaths)))
# What was the date when the most new cases occured?
# `date_most_cases`
date_most_cases <- select(filter(national, new_cases == max(new_cases)), date)
# What was the date when the most new deaths occured?
# `date_most_deaths`
date_most_deaths <- select(filter(national, new_deaths == max(new_deaths)), date)
# How many people died on the date when the most deaths occured? `most_deaths`
most_deaths <- select(filter(national, new_deaths == max(new_deaths)), deaths)
# Grouped analysis --------------------------------------------------------
# An incredible power of R is to perform the same computation *simultaneously*
# across groups of rows. The following questions rely on that capability.
# What is the county with the *current* (e.g., on the most recent date)
# highest number of cases in each state? Your answer, stored in
# `highest_in_each_state`, should be a *vector* of
# `location` names (the column with COUNTY, STATE).
# Hint: be careful about the order of filtering your data!
grouped_location <- group_by(counties, state)
counties_recent <- filter(grouped_location, date == max(date))
highest_in_each_state <- select(filter(counties_recent, cases == max(cases)), location)
# What is the county with the *current* (e.g., on the most recent date)
# lowest number of deaths in each state? Your answer, stored in
# `lowest_in_each_state`, should be a *vector* of
# `location` names (the column with COUNTY, STATE).
lowest_in_each_state <- select(filter(counties_recent, cases == min(cases)), location)
# Reflection: Why are there so many observations (counties) in the variable
# `lowest_in_each_state` (i.e., wouldn't you expect the number to be ~50)?
# The following is a check on our understanding of the data.
# Presumably, if we add up all of the cases on each day in the
# `states` or `counties` dataset, they should add up to the number at the
# `national` level. So, let's check.
# First, let's create `state_by_day` by adding up the cases on each day in the
# `states` dataframe. For clarity, let's call the column with the total cases
# `state_total`
# This will be a dataframe with the columns `date` and `state_total`.
grouped_state_dates <- group_by(states, date)
state_by_day <- summarize(grouped_state_dates, state_total = sum(cases))
print(state_by_day)
# Next, let's create `county_by_day` by adding up the cases on each day in the
# `counties` dataframe. For clarity, let's call the column with the total cases
# `county_total`
# This will also be a dataframe, with the columns `date` and `county_total`.
grouped_county_dates <- group_by(counties, date)
county_by_day <- summarize(grouped_county_dates, county_total = sum(cases))
# Now, there are a few ways to check if they are always equal. To start,
# let's *join* those two dataframes into one called `totals_by_day`
totals_by_day <- merge(x = state_by_day, y = county_by_day, all = TRUE)
# Next, let's create a variable `all_totals` by joining `totals_by_day`
# to the `national` dataframe
all_totals <- merge(x = national, y = totals_by_day, all = TRUE)
# How many rows are there where the state total *doesn't equal* the natinal
# cases reported? `num_state_diff`
num_state_diff <- sum(all_totals$cases != all_totals$state_total, na.rm = TRUE)
# How many rows are there where the county total *doesn't equal* the natinal
# cases reported? `num_county_diff`
num_county_diff <- sum(all_totals$cases != all_totals$county_total, na.rm = TRUE)
# Oh no! An inconsistency -- let's dig further into this. Let's see if we can
# find out *where* this inconsistency lies. Let's take the county level data,
# and add up all of the cases to the state level on each day (e.g.,
# aggregating to the state level). Store this dataframe with three columns
# (state, date, county_totals) in the variable `sum_county_to_state`.
# (To avoid DPLYR automatically grouping your results,
# specify `.groups = "drop"` in your `summarize()` statement. This is a bit of
# an odd behavior....)
sum_county_to_state <- counties %>%
group_by(date, state)%>%
summarize(county_totals = sum(cases), .groups = "drop")
# Then, let's join together the `sum_county_to_state` dataframe with the
# `states` dataframe into the variable `joined_states`.
joined_states <- merge(x = sum_county_to_state, y = states, all = TRUE)
# To find out where (and when) there is a discrepancy in the number of cases,
# create the variable `has_discrepancy`, which has *only* the observations
# where the sum of the county cases in each state and the state values are
# different. This will be a *dataframe*.
has_discrepancy <- joined_states%>%
filter(county_totals != cases)
# Next, lets find the *state* where there is the *highest absolute difference*
# between the sum of the county cases and the reported state cases.
# `state_highest_difference`.
# (hint: you may want to create a new column in `has_discrepancy` to do this.)
state_highest_difference <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
filter(abs_diff == max(abs_diff))%>%
pull(state)
# Independent exploration -------------------------------------------------
# Ask your own 3 questions: in the section below, pose 3 questions,
# then use the appropriate code to answer them.
# What was the highest absolute difference between the sum of the county cases and the reported state cases?
state_highest_diff_amt <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
filter(abs_diff == max(abs_diff))%>%
select(abs_diff)
# What date was the highest discrepency between sum of county cases and reported state cases on?
date_highest_diff_amt <- has_discrepancy%>%
mutate(abs_diff = abs(county_totals - cases))%>%
filter(abs_diff == max(abs_diff))%>%
select(date)
# How many discprencies does each state with reported discrepencies have?
state_most_discrepencies <- table(has_discrepancy['state'])
# Reflection: What surprised you the most throughout your analysis?
obs_national
obs_states
obs_counties
num_features_counties
num_features_national
num_features_states
total_us_cases
total_us_deaths
state_highest_cases
num_highest_state
state_highest_ratio
state_lowest_cases
county_highest_cases
num_highest_cases_county
location_most_deaths
date_most_cases
date_most_deaths
most_deaths
highest_in_each_state
highest_in_each_state <- counties%>%
group_by(state)%>%
filter(date == max(date))%>%
filter(cases == max(cases))%>%
select(location)
highest_in_each_state
lowest_in_each_state
lowest_in_each_state <-
group_by(state)%>%
filter(date == max(date))%>%
filter(cases == min(cases))%>%
select(location)
lowest_in_each_state
lowest_in_each_state <- counties%>%
group_by(state)%>%
filter(date == max(date))%>%
filter(cases == min(cases))%>%
select(location)
lowest_in_each_state
state_by_day
state_by_day <- states%>%
group_by(date)%>%
summarize(state_total = sum(cases))
state_by_day
state_by_day <- states%>%
group_by(date)%>%
summarize(state_total = sum(cases))
state_by_day
county_by_day
county_by_day <- counties%>%
group_by(date)%>%
summarize(county_total = sum(cases))
county_by_day
num_state_diff
num_county_diff
state_highest_difference
source("C:/Users/toric/Documents/info201/lecture-exercises/lect8.R")
graph_seattle_crime
options(repos=structure(c(CRAN="http://cran.r-project.org")))
options(repos=structure(c(CRAN="http://cran.r-project.org")))
options(repos=structure(c(CRAN="http://cran.r-project.org")))
options(repos=structure(c(CRAN="http://cran.r-project.org")))
options(repos=structure(c(CRAN="http://cran.r-project.org")))
options(repos=structure(c(CRAN="http://cran.r-project.org")))
shiny::runApp('C:/Users/toric/Documents/info201/lecture-exercises/lect_app')
species <- read.csv("C:\Users\toric\Documents\info201\final-project-cjsv\scripts\data\national_parks_biodiversity")
source("C:/Users/toric/Documents/info201/final-project-cjsv/scripts/chart_2.R")
chart_2
library(tidyverse)
library(ggplot2)
library(patchwork)
parks <- read.csv("scripts/data/national_parks_biodiversity/parks.csv")
species <- read.csv("scripts/data/national_parks_biodiversity/species.csv")
states <- merge(x = parks, y = species, all.x = TRUE)
unique_species <- states %>%
group_by(state)%>%
summarize(species_amount = length(unique(order)))%>%
mutate(id = seq(1,27))
unique_species = unique_species %>%
arrange(state, species_amount)
label_data <- unique_species
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5)/number_of_bar
label_data$hjust <- ifelse(angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)
chart_2 <- ggplot(unique_species, aes(x = as.factor(state), y = species_amount))+
geom_bar(stat="identity", fill=alpha("blue", 0.3))+
ylim(-100, 450)+
theme_minimal()+
theme(
axis.text = element_blank(),
axis.title = element_blank(),
panel.grid = element_blank(),
plot.margin = unit(rep(-2,4), "cm")
)+
coord_polar(start = 0) +
geom_text(data = label_data, aes(x=state, y=species_amount+10, label = state, hjust = hjust), color = "black",
fontface = "bold", alpha = 0.6, size = 2.5, angle = label_data$angle, inherit.aes = FALSE)
chart_2
unique_species <- states %>%
group_by(state)%>%
summarize(species_amount = length(unique(order)))%>%
mutate(id = seq(1,27))
unique_species = unique_species %>%
arrange(state, species_amount)
label_data <- unique_species
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5)/number_of_bar
label_data$hjust <- ifelse(angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)
states <- merge(x = parks, y = species, all.x = TRUE)
unique_species <- states %>%
group_by(state)%>%
summarize(species_amount = length(unique(order)))%>%
mutate(id = seq(1,27))
library(tidyverse)
library(ggplot2)
library(patchwork)
parks <- read.csv("scripts/data/national_parks_biodiversity/parks.csv")
species <- read.csv("scripts/data/national_parks_biodiversity/species.csv")
states <- merge(x = parks, y = species, all.x = TRUE)
setwd("C:/Users/toric/Documents/info201/final-project-cjsv")
source("C:/Users/toric/Documents/info201/final-project-cjsv/scripts/chart_2.R")
chart_2
